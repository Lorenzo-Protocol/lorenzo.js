// @generated by protoc-gen-es v1.0.0
// @generated from file lorenzo/token/v1/tx.proto (package lorenzo.token.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Metadata } from "../../../cosmos/bank/v1beta1/bank_pb.js";
import type { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import type { Params } from "./genesis_pb.js";

/**
 * MsgRegisterCoin registers a token pair for existing coin
 * NOTE: this is a governance message.
 *
 * @generated from message lorenzo.token.v1.MsgRegisterCoin
 */
export declare class MsgRegisterCoin extends Message<MsgRegisterCoin> {
  /**
   * authority is the address that can update the parameters
   *
   * @generated from field: string authority = 1;
   */
  authority: string;

  /**
   * metadata slice of coins
   *
   * @generated from field: repeated cosmos.bank.v1beta1.Metadata metadata = 2;
   */
  metadata: Metadata[];

  constructor(data?: PartialMessage<MsgRegisterCoin>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgRegisterCoin";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRegisterCoin;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRegisterCoin;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRegisterCoin;

  static equals(a: MsgRegisterCoin | PlainMessage<MsgRegisterCoin> | undefined, b: MsgRegisterCoin | PlainMessage<MsgRegisterCoin> | undefined): boolean;
}

/**
 * @generated from message lorenzo.token.v1.MsgRegisterCoinResponse
 */
export declare class MsgRegisterCoinResponse extends Message<MsgRegisterCoinResponse> {
  constructor(data?: PartialMessage<MsgRegisterCoinResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgRegisterCoinResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRegisterCoinResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRegisterCoinResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRegisterCoinResponse;

  static equals(a: MsgRegisterCoinResponse | PlainMessage<MsgRegisterCoinResponse> | undefined, b: MsgRegisterCoinResponse | PlainMessage<MsgRegisterCoinResponse> | undefined): boolean;
}

/**
 * MsgRegisterERC20 registers a token pair for existing erc20 contract
 * NOTE: this is a governance message.
 *
 * @generated from message lorenzo.token.v1.MsgRegisterERC20
 */
export declare class MsgRegisterERC20 extends Message<MsgRegisterERC20> {
  /**
   * authority is the address that can update the parameters
   *
   * @generated from field: string authority = 1;
   */
  authority: string;

  /**
   * metadata slice of erc20 token contract addresses
   *
   * @generated from field: repeated string contract_addresses = 2;
   */
  contractAddresses: string[];

  constructor(data?: PartialMessage<MsgRegisterERC20>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgRegisterERC20";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRegisterERC20;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRegisterERC20;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRegisterERC20;

  static equals(a: MsgRegisterERC20 | PlainMessage<MsgRegisterERC20> | undefined, b: MsgRegisterERC20 | PlainMessage<MsgRegisterERC20> | undefined): boolean;
}

/**
 * @generated from message lorenzo.token.v1.MsgRegisterERC20Response
 */
export declare class MsgRegisterERC20Response extends Message<MsgRegisterERC20Response> {
  constructor(data?: PartialMessage<MsgRegisterERC20Response>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgRegisterERC20Response";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRegisterERC20Response;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRegisterERC20Response;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRegisterERC20Response;

  static equals(a: MsgRegisterERC20Response | PlainMessage<MsgRegisterERC20Response> | undefined, b: MsgRegisterERC20Response | PlainMessage<MsgRegisterERC20Response> | undefined): boolean;
}

/**
 * MsgToggleConversion toggles the conversion for a token pair
 * NOTE: this is a governance message.
 *
 * @generated from message lorenzo.token.v1.MsgToggleConversion
 */
export declare class MsgToggleConversion extends Message<MsgToggleConversion> {
  /**
   * authority is the address that can update the parameters
   *
   * @generated from field: string authority = 1;
   */
  authority: string;

  /**
   * token is in format of either coin base denom or erc20 contract address
   *
   * @generated from field: string token = 2;
   */
  token: string;

  constructor(data?: PartialMessage<MsgToggleConversion>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgToggleConversion";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgToggleConversion;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgToggleConversion;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgToggleConversion;

  static equals(a: MsgToggleConversion | PlainMessage<MsgToggleConversion> | undefined, b: MsgToggleConversion | PlainMessage<MsgToggleConversion> | undefined): boolean;
}

/**
 * @generated from message lorenzo.token.v1.MsgToggleConversionResponse
 */
export declare class MsgToggleConversionResponse extends Message<MsgToggleConversionResponse> {
  constructor(data?: PartialMessage<MsgToggleConversionResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgToggleConversionResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgToggleConversionResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgToggleConversionResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgToggleConversionResponse;

  static equals(a: MsgToggleConversionResponse | PlainMessage<MsgToggleConversionResponse> | undefined, b: MsgToggleConversionResponse | PlainMessage<MsgToggleConversionResponse> | undefined): boolean;
}

/**
 * MsgConvertCoin converts a coin to an ERC20 token
 *
 * @generated from message lorenzo.token.v1.MsgConvertCoin
 */
export declare class MsgConvertCoin extends Message<MsgConvertCoin> {
  /**
   * coin to be converted
   *
   * @generated from field: cosmos.base.v1beta1.Coin coin = 1;
   */
  coin?: Coin;

  /**
   * receiver of the erc20 token, evm hex format address.
   *
   * @generated from field: string receiver = 2;
   */
  receiver: string;

  /**
   * sender of the coin, lorenzo bech32 format address.
   *
   * @generated from field: string sender = 3;
   */
  sender: string;

  constructor(data?: PartialMessage<MsgConvertCoin>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgConvertCoin";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgConvertCoin;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgConvertCoin;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgConvertCoin;

  static equals(a: MsgConvertCoin | PlainMessage<MsgConvertCoin> | undefined, b: MsgConvertCoin | PlainMessage<MsgConvertCoin> | undefined): boolean;
}

/**
 * @generated from message lorenzo.token.v1.MsgConvertCoinResponse
 */
export declare class MsgConvertCoinResponse extends Message<MsgConvertCoinResponse> {
  constructor(data?: PartialMessage<MsgConvertCoinResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgConvertCoinResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgConvertCoinResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgConvertCoinResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgConvertCoinResponse;

  static equals(a: MsgConvertCoinResponse | PlainMessage<MsgConvertCoinResponse> | undefined, b: MsgConvertCoinResponse | PlainMessage<MsgConvertCoinResponse> | undefined): boolean;
}

/**
 * MsgConvertERC20 converts an ERC20 token to a coin
 *
 * @generated from message lorenzo.token.v1.MsgConvertERC20
 */
export declare class MsgConvertERC20 extends Message<MsgConvertERC20> {
  /**
   * contract address of the ERC20 token
   *
   * @generated from field: string contract_address = 1;
   */
  contractAddress: string;

  /**
   * amount of tokens to be converted
   *
   * @generated from field: string amount = 2;
   */
  amount: string;

  /**
   * receiver of the coin
   *
   * @generated from field: string receiver = 3;
   */
  receiver: string;

  /**
   * sender of the ERC20 token
   *
   * @generated from field: string sender = 4;
   */
  sender: string;

  constructor(data?: PartialMessage<MsgConvertERC20>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgConvertERC20";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgConvertERC20;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgConvertERC20;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgConvertERC20;

  static equals(a: MsgConvertERC20 | PlainMessage<MsgConvertERC20> | undefined, b: MsgConvertERC20 | PlainMessage<MsgConvertERC20> | undefined): boolean;
}

/**
 * @generated from message lorenzo.token.v1.MsgConvertERC20Response
 */
export declare class MsgConvertERC20Response extends Message<MsgConvertERC20Response> {
  constructor(data?: PartialMessage<MsgConvertERC20Response>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgConvertERC20Response";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgConvertERC20Response;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgConvertERC20Response;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgConvertERC20Response;

  static equals(a: MsgConvertERC20Response | PlainMessage<MsgConvertERC20Response> | undefined, b: MsgConvertERC20Response | PlainMessage<MsgConvertERC20Response> | undefined): boolean;
}

/**
 * MsgUpdateParams updates the convert module parameters
 *
 * @generated from message lorenzo.token.v1.MsgUpdateParams
 */
export declare class MsgUpdateParams extends Message<MsgUpdateParams> {
  /**
   * authority is the address that can update the parameters
   *
   * @generated from field: string authority = 1;
   */
  authority: string;

  /**
   * params are the new parameters
   *
   * @generated from field: lorenzo.token.v1.Params params = 2;
   */
  params?: Params;

  constructor(data?: PartialMessage<MsgUpdateParams>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgUpdateParams";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParams;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParams;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParams;

  static equals(a: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined, b: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined): boolean;
}

/**
 * @generated from message lorenzo.token.v1.MsgUpdateParamsResponse
 */
export declare class MsgUpdateParamsResponse extends Message<MsgUpdateParamsResponse> {
  constructor(data?: PartialMessage<MsgUpdateParamsResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "lorenzo.token.v1.MsgUpdateParamsResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParamsResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse;

  static equals(a: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined, b: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined): boolean;
}

